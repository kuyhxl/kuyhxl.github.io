+++
title = "[OS] 01. System Call"
date = "2025-09-15T11:02:09+09:00"
draft = true
categories = ["OS"]
tags = ["OS"]
pin = false
mathJax = false
katex = true

+++

# 운영체제 정리 시리즈 #1 - 시스템 콜(System Call)

이 시리즈는 University of Wisconsin의 Remzi H. Arpaci-Dusseau 교수님이 집필한 
[**Operating Systems: Three Easy Pieces (OSTEP)**](https://pages.cs.wisc.edu/~remzi/OSTEP/) 교재를 바탕으로, 
운영체제의 핵심 개념들을 **내가 이해한 방식대로 정리하고 기록**하기 위해 시작했다.

이번 첫 번째 글에서는, **User Program이 어떻게 운영체제 커널에 요청을 보내는지**, 
그리고 그 핵심 메커니즘인 **시스템 콜(System Call)**에 대해 살펴본다.

---

## 1. 시스템 콜이란?

> 시스템 콜(System Call)은 **사용자 프로그램이 운영체제의 기능을 요청할 수 있도록 하는 인터페이스**이다.

예를 들어, 우리가 파일을 열거나, 데이터를 쓰거나, 메모리를 할당할 때 등,  
실제로는 **운영체제가 대신 일을 처리해준다**.

왜냐하면, User levelProgram은 보안을 위해 **직접 하드웨어에 접근할 수 없기 때문에**, 이러한 요청은 반드시 **운영체제를 통해서 간접적으로 수행되어야 한다.**

> Program이란 어떤 목적을 수행하기 위해 작성된 명령어들의 집합이다. 그것들이 메모리에 load되어 실행될 때 process가 된다. 

---

## 2. User Mode and Kernel Mode

운영체제는 보안과 안정성을 위해 두 개의 실행 모드를 제공한다.

| 모드            | 설명                                                        |
| --------------- | ----------------------------------------------------------- |
| **User Mode**   | 일반 응용 프로그램이 실행되는 모드. 제한된 권한만 가짐      |
| **Kernel Mode** | 운영체제 커널이 실행되는 모드. 전체 시스템 자원에 접근 가능 |

사용자 모드의 프로그램이 커널 기능을 사용하려면, **시스템 콜을 통해 커널 모드로 전환**되어야 한다.

![Linux/Unix Architecture](/images/[OS]-01.-Preview/IMG_A7020F62C76B-1.jpeg)

*“Layered architecture of a Linux/UNIX-like operating system stack.”*

운영체제는 단순히 커널 코드의 집합이 아니라,  **사용자 요청이 하드웨어까지 도달하는 과정 전체를 계층적으로 관리하는 시스템 구조**를 가지고 있다.

위의 다이어그램은 Linux/UNIX 계열 운영체제의 전형적인 시스템 구조를 보여준다.

---

## 3. 시스템 콜이 호출되는 상황

| **상황**                     | **시스템 콜 예시**                |
| ---------------------------- | --------------------------------- |
| 파일 입출력                  | open, read, write, close          |
| 프로세스 생성/종료           | fork, execve, wait, exit          |
| 메모리 할당                  | mmap, brk                         |
| 사용자 정보 확인             | getuid, setuid                    |
| 시간 관련(인터럽트와 타이머) | sleep, gettimeofday               |
| 네트워크 통신                | socket, bind, connect, recv, send |

일반적으로 표준 라이브러리 함수가 시스템 콜을 감싸고 있기 때문에, 우리가 Printf()나 malloc()처럼 친숙한 함수를 호출해도, 내부적으로는 시스템 콜이 일어날 수 있다. 

## 4. 시스템 콜 흐름

아래의 흐름도는 시스템 콜이 호출되는 구체적인 경로를 미시적으로 보여준다. 

![System call Handling](/images/[OS]-01.-Preview/Nothing-73.jpg)

\>  `strcpy()`는 단순 메모리 연산기능이라 Uesr Level에서 모두 처리된다. 즉,  커널 기능을 사용하지 않기 때문에 시스템 콜로 연결되지 않는다.

\> **System Call Stub**는 사용자 모드 프로그램에서 커널모드의 시스템 콜을 요청할 때 사용하는 중간다리 함수다.



아래의 사진은 i386기반 리눅스 시스템에서의 system call의 흐름을 다루고 있다. 

![Nothing-76](/images/[OS]-01.-Preview/Nothing-76.jpg)

*Invoke fork() system call (i386-linux system)*

**① User program에서 fork()를 호출**

**② glibc 내부**

- 시스템콜 스텁이라고 불리는 영역이다.

```assembly
movl $2, %eax ; fork의 시스템콜 번호 2를 레지스터 eax에 저장
int $0x80 ; 소프트웨어 인터럽트 명령어로 커널 진입 -> trap
```

> 0x80은 리눅스에서 시스템 콜 인터럽트 번호이다. 이것 이외에도 0x0은 divide by zero, 0x1은 debug exception 256가지 인터럽트가 있다.

> **Trap이란:** **현재 실행 중인 프로세스의 흐름을 멈추고 커널 모드로 안전하게 점프시키는 메커니즘**이다. 보통 **예외(exception)나 시스템 콜**을 처리할 때 사용된다. 즉, 고의적인 인터럽트라고 생각하면 된다.

**③ Interrupt Vector Table(IVC)**

- CPU는 int 0x80명령을 감지하고 인터럽트 벡터테이블에서 0x80번에 등록된 핸들러 system_call을 실행한다. 

> IVC는 CPU가 인터럽트를 받았을 때 참조하는 함수 주소표이다. 

**④ 커널 진입 및 system_call 처리**

- system_call 핸들러는 다음을 수행: 

```assembly
ENTRY(system_call)
  SAVE_ALL
  call *sys_call_table(, %eax, 4)  ; %eax = 2 → sys_call_table[2] = sys_fork
  #커널은 eax에 들어있는 값(시스템 콜 번호)을 통해 시스템콜 테이블에서 해당함수(sys_fork)를 찾아 호출
```

**⑤ System Call Table & sys_fork()실행**

- 시스템 콜 번호 2번에 대응되는 함수는 sys_fork()
- 해당 함수는 실제 커널 소스 파일인 fork.c와 process.c에 구현됨

~~ 유저 프로그램에서 `printf()` 같은 함수를 호출하면, 
이 함수는 내부적으로 시스템 콜 `write()`를 호출하게 됩니다.

이때 시스템 콜 번호는 보통 `%eax` 레지스터에 저장되며,
그 다음 `int $0x80` 명령을 통해 커널에 인터럽트를 발생시킵니다.

CPU는 인터럽트 벡터 테이블에서 0x80번에 등록된 `system_call()` 함수를 호출하고,
커널은 `sys_call_table[]`을 참고해 해당 시스템 콜 번호에 맞는 함수를 실행합니다.

결과적으로, 유저 프로그램이 직접 커널 함수를 호출하는 것이 아니라,
**레지스터 + 인터럽트 + 시스템 콜 테이블**을 통해 안전하게 커널 기능에 접근하는 구조입니다. ~~ 

## 5. 마지막 정리

시스템 콜은 사용자 프로그램과 운영체제를 연결하는 통로이며, OS는 이를 통해 시스템 자원을 안전하고 일관되게 제어한다. 

| **용어**                         | **정의 / 역할**                                              | **하드웨어/소프트웨어** | **관련 키워드**                   |
| -------------------------------- | ------------------------------------------------------------ | ----------------------- | --------------------------------- |
| **Trap**                         | 사용자 모드에서 커널 모드로 전환하는 메커니즘 (예외, 시스템 콜 등) | 하드웨어 + 소프트웨어   | int 0x80, system call, exception  |
| **Interrupt**                    | 외부 이벤트로 CPU 흐름을 바꾸는 신호 (입출력, 타이머 등)     | 하드웨어                | IRQ, I/O, 비동기                  |
| **System Call**                  | 사용자 프로그램이 커널 기능을 요청하는 인터페이스(통로)      | 소프트웨어              | fork(), write(), read()           |
| **System Call Number**           | 시스템 콜을 식별하는 고유한 번호                             | 소프트웨어              | %eax, mov, syscall index          |
| **System Call Stub**             | 라이브러리 내부에서 시스템 콜 호출을 담당하는 얇은 어셈블리 코드 | 소프트웨어 (glibc)      | int 0x80, syscall wrapper         |
| **System Call Table**            | 시스템 콜 번호 → 커널 함수 주소 매핑하는 배열                | 소프트웨어 (커널 내부)  | sys_call_table[], sys_fork()      |
| **Interrupt Vector Table (IVT)** | 인터럽트 번호 → 핸들러 주소 매핑하는 테이블                  | 하드웨어                | 256개 한정, 0x80, divide_by_zero  |
| **Vector** (in IVT)              | CPU가 참조하는 **인터럽트 핸들러 주소값** (즉, 방향을 가리키는 포인터) | 하드웨어적 용어         | “점프할 방향”, function pointer   |
| **Kernel Mode**                  | OS 핵심 기능이 실행되는 모드 (모든 자원 접근 가능)           | OS 실행 컨텍스트        | privileged mode, supervisor       |
| **User Mode**                    | 일반 프로그램이 실행되는 제한된 모드                         | OS 실행 컨텍스트        | restricted, syscall로만 커널 접근 |